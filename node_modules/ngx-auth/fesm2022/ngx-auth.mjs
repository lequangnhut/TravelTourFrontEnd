import * as i1 from '@angular/common/http';
import { HTTP_INTERCEPTORS } from '@angular/common/http';
import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Inject, inject, NgModule } from '@angular/core';
import { Subject, throwError } from 'rxjs';
import { switchMap, catchError, first, map } from 'rxjs/operators';
import { DOCUMENT } from '@angular/common';
import * as i1$1 from '@angular/router';

const AUTH_SERVICE = new InjectionToken('AUTH_SERVICE');
const PUBLIC_FALLBACK_PAGE_URI = new InjectionToken('PUBLIC_FALLBACK_PAGE_URI');
const PROTECTED_FALLBACK_PAGE_URI = new InjectionToken('PROTECTED_FALLBACK_PAGE_URI');

/**
 * Essential service for authentication
 */
class AuthService {
}

class AuthInterceptor {
    authService;
    http;
    /**
     * Is refresh token is being executed
     */
    refreshInProgress = false;
    /**
     * Notify all outstanding requests through this subject
     */
    refreshSubject = new Subject();
    constructor(authService, http) {
        this.authService = authService;
        this.http = http;
    }
    /**
     * Intercept an outgoing `HttpRequest`
     */
    intercept(req, delegate) {
        if (this.skipRequest(req)) {
            return delegate.handle(req);
        }
        return this.processIntercept(req, delegate);
    }
    /**
     * Process all the requests via custom interceptors.
     */
    processIntercept(original, delegate) {
        const clone = original.clone();
        return this.request(clone)
            .pipe(switchMap((req) => delegate.handle(req)), catchError((res) => this.responseError(clone, res)));
    }
    /**
     * Request interceptor. Delays request if refresh is in progress
     * otherwise adds token to the headers
     */
    request(req) {
        if (this.refreshInProgress) {
            return this.delayRequest(req);
        }
        return this.addToken(req);
    }
    /**
     * Failed request interceptor, check if it has to be processed with refresh
     */
    responseError(req, res) {
        const refreshShouldHappen = this.authService.refreshShouldHappen(res, req);
        if (refreshShouldHappen && !this.refreshInProgress) {
            this.refreshInProgress = true;
            this.authService.refreshToken()
                .subscribe({
                next: () => {
                    this.refreshInProgress = false;
                    this.refreshSubject.next(true);
                },
                error: () => {
                    this.refreshInProgress = false;
                    this.refreshSubject.next(false);
                },
            });
        }
        if (refreshShouldHappen && this.refreshInProgress) {
            return this.retryRequest(req, res);
        }
        return throwError(() => res);
    }
    /**
     * Add access token to headers or the request
     */
    addToken(req) {
        return this.authService.getAccessToken()
            .pipe(first(), map((token) => {
            if (token) {
                return req.clone({
                    setHeaders: this.authService.getHeaders?.(token) ?? { Authorization: `Bearer ${token}` },
                });
            }
            return req;
        }));
    }
    /**
     * Delay request, by subscribing on refresh event, once it finished, process it
     * otherwise throw error
     */
    delayRequest(req) {
        return this.refreshSubject.pipe(first(), switchMap((status) => status ? this.addToken(req) : throwError(() => req)));
    }
    /**
     * Retry request, by subscribing on refresh event, once it finished, process it
     * otherwise throw error
     */
    retryRequest(req, res) {
        return this.refreshSubject.pipe(first(), switchMap((status) => status ? this.http.request(req) : throwError(() => res || req)));
    }
    /**
     * Checks if request must be skipped by interceptor.
     */
    skipRequest(req) {
        return this.authService.skipRequest?.(req) || this.authService.verifyRefreshToken?.(req);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: AuthInterceptor, deps: [{ token: AUTH_SERVICE }, { token: i1.HttpClient }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: AuthInterceptor });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: AuthInterceptor, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: AuthService, decorators: [{
                    type: Inject,
                    args: [AUTH_SERVICE]
                }] }, { type: i1.HttpClient }]; } });

/**
 * Guard, checks access token availability and allows or disallows access to page,
 * and redirects out
 */
class ProtectedGuard {
    authService;
    publicFallbackPageUri;
    document;
    router;
    constructor(authService, publicFallbackPageUri, document, router) {
        this.authService = authService;
        this.publicFallbackPageUri = publicFallbackPageUri;
        this.document = document;
        this.router = router;
    }
    /**
     * CanActivate handler
     */
    canActivate(state) {
        return this.authService.isAuthorized()
            .pipe(map((isAuthorized) => {
            if (!isAuthorized && !this.isPublicPage(state)) {
                this.authService.setInterruptedUrl?.(state.url);
                this.navigate(this.publicFallbackPageUri);
                return false;
            }
            return true;
        }));
    }
    /**
     * Check, if current page is fallback page
     */
    isPublicPage(state) {
        return state.url === this.publicFallbackPageUri;
    }
    /**
     * Navigate away from the app / path
     */
    navigate(url) {
        if (url.startsWith('http')) {
            this.document.location.href = url;
        }
        else {
            this.router.navigateByUrl(url);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: ProtectedGuard, deps: [{ token: AUTH_SERVICE }, { token: PUBLIC_FALLBACK_PAGE_URI }, { token: DOCUMENT }, { token: i1$1.Router }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: ProtectedGuard });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: ProtectedGuard, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: AuthService, decorators: [{
                    type: Inject,
                    args: [AUTH_SERVICE]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PUBLIC_FALLBACK_PAGE_URI]
                }] }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i1$1.Router }]; } });
const protectedGuard = (_route, state) => {
    const guard = inject(ProtectedGuard);
    return guard.canActivate(state);
};

/**
 * Guard, checks access token availability and allows or disallows access to page,
 * and redirects out
 */
class PublicGuard {
    authService;
    protectedFallbackPageUri;
    document;
    router;
    constructor(authService, protectedFallbackPageUri, document, router) {
        this.authService = authService;
        this.protectedFallbackPageUri = protectedFallbackPageUri;
        this.document = document;
        this.router = router;
    }
    /**
     * CanActivate handler
     */
    canActivate(state) {
        return this.authService.isAuthorized()
            .pipe(map((isAuthorized) => {
            if (isAuthorized && !this.isProtectedPage(state)) {
                this.navigate(this.protectedFallbackPageUri);
                return false;
            }
            return true;
        }));
    }
    /**
     * Check, if current page is protected fallback page
     */
    isProtectedPage(state) {
        return state.url === this.protectedFallbackPageUri;
    }
    /**
     * Navigate away from the app / path
     */
    navigate(url) {
        if (url.startsWith('http')) {
            this.document.location.href = url;
        }
        else {
            this.router.navigateByUrl(url);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: PublicGuard, deps: [{ token: AUTH_SERVICE }, { token: PROTECTED_FALLBACK_PAGE_URI }, { token: DOCUMENT }, { token: i1$1.Router }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: PublicGuard });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: PublicGuard, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: AuthService, decorators: [{
                    type: Inject,
                    args: [AUTH_SERVICE]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PROTECTED_FALLBACK_PAGE_URI]
                }] }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i1$1.Router }]; } });
const publicGuard = (_route, state) => {
    const guard = inject(PublicGuard);
    return guard.canActivate(state);
};

class AuthModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: AuthModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.0.4", ngImport: i0, type: AuthModule });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: AuthModule, providers: [
            PublicGuard,
            ProtectedGuard,
            AuthInterceptor,
            {
                provide: HTTP_INTERCEPTORS,
                useClass: AuthInterceptor,
                multi: true,
            },
        ] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: AuthModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [
                        PublicGuard,
                        ProtectedGuard,
                        AuthInterceptor,
                        {
                            provide: HTTP_INTERCEPTORS,
                            useClass: AuthInterceptor,
                            multi: true,
                        },
                    ],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { AUTH_SERVICE, AuthModule, AuthService, PROTECTED_FALLBACK_PAGE_URI, PUBLIC_FALLBACK_PAGE_URI, protectedGuard, publicGuard };
//# sourceMappingURL=ngx-auth.mjs.map
